    def background_linear_gradient(self, angle: float, colors: list[Color]) -> 'Container':
        colors_hex = [color.hex for color in colors]
        colors_ffi = questpdf_ffi.new("uint32_t[]", colors_hex)
        result = questpdf.lib.questpdf__container__background_linear_gradient(self.target_pointer, angle, colors_ffi, len(colors_ffi))
        return Container(result)
    
    def border_linear_gradient(self, angle: float, colors: list[Color]) -> 'Container':
        colors_hex = [color.hex for color in colors]
        colors_ffi = questpdf_ffi.new("uint32_t[]", colors_hex)
        result = questpdf.lib.questpdf__container__border_linear_gradient(self.target_pointer, angle, colors_ffi, len(colors_ffi))
        return Container(result)

    def shadow(self, *, blur: float = 0, color: Color = Colors.black, offset_x: float = 0, offset_y: float = 0, spread: float = 0) -> 'Container':
        result = questpdf.lib.questpdf__container__shadow(self.target_pointer, blur, color.hex, offset_x, offset_y, spread)
        return Container(result)


    @overload
    def text(self, source: str) -> 'TextBlockDescriptor': ...

    @overload
    def text(self, source: Callable[['TextDescriptor'], list[Any]]) -> None: ...

    def text(self, source: Union[str, Callable[['TextDescriptor'], list[Any]]]) -> Optional['TextBlockDescriptor']:
        if isinstance(source, str):
            return self._text_string(source)
    
        elif callable(source):
            return self._text_action(source)
    
        else:
            raise TypeError(f"Expected str or Callable, got {type(source)}")
    
    def _svg_func(self, source: Callable[[DynamicSvgPayload], str]) -> None:
        @questpdf_ffi.callback("char*(DynamicSvgSourcePayload)")
        def native_callback(c_payload):
            payload = DynamicSvgPayload(c_payload)
            result_str = source(payload)
            return questpdf_ffi.new("char[]", result_str.encode('utf-8'))

        self._callbacks.append(native_callback)

        questpdf.lib.questpdf__container__svg_dynamic(self.target_pointer, native_callback)

    @overload
    def svg(self, source: str) -> 'SvgImageDescriptor': ...
    
    @overload
    def svg(self, source: SvgImage) -> 'SvgImageDescriptor': ...
    
    @overload
    def svg(self, source: Callable[['DynamicSvgPayload'], str]) -> None: ...
    
    def svg(self, source: Union[str, SvgImage, Callable[['DynamicSvgPayload'], str]]) -> Optional['SvgImageDescriptor']:
        if isinstance(source, str):
            return self._svg_string(source)
    
        elif isinstance(source, SvgImage):
            return self._svg_svg_image(source)
    
        elif callable(source):
            return self._svg_func(source)
    
        else:
            raise TypeError(f"Expected str, SvgImage, or Callable, got {type(source)}")



    def _image_bytes(self, data: bytes) -> 'ImageDescriptor':
        buffer = questpdf_ffi.new("Buffer*")
        buffer.data = questpdf_ffi.from_buffer("uint8_t[]", data)
        buffer.length = len(data)

        result = questpdf.lib.questpdf__container__image_bytes(self.target_pointer, buffer[0])
        return ImageDescriptor(result)

    def _image_func(self, source: Callable[[DynamicImagePayload], bytes]) -> 'ImageDescriptor':
        @questpdf_ffi.callback("Buffer(DynamicImageSourcePayload)")
        def native_callback(c_payload):
            payload = DynamicImagePayload(c_payload)
            result_bytes = source(payload)

            data_ptr = questpdf_ffi.new("uint8_t[]", result_bytes)

            buffer = questpdf_ffi.new("Buffer*")
            buffer.data = data_ptr
            buffer.length = len(result_bytes)
            return buffer[0]

        # Store callback reference to prevent garbage collection
        self._callbacks.append(native_callback)

        result = questpdf.lib.questpdf__container__image_dynamic(self.target_pointer, native_callback)
        return ImageDescriptor(result)

    

    @overload
    def image(self, source: str) -> 'ImageDescriptor': ...
    
    @overload
    def image(self, source: bytes) -> 'ImageDescriptor': ...
    
    @overload
    def image(self, source: Image) -> 'ImageDescriptor': ...
    
    @overload
    def image(self, source: Callable[['Size'], str]) -> 'DynamicImageDescriptor': ...
    
    def image(self, source: Union[str, bytes, 'Image', Callable[['DynamicImagePayload'], bytes]]) -> Union['ImageDescriptor', 'DynamicImageDescriptor']:
        if isinstance(source, str):
            return self._image_string(source)

        if isinstance(source, bytes):
            return self._image_bytes(source)

        elif isinstance(source, Image):
            return self._image_image(source)
    
        elif callable(source):
            return self._image_func(source)
    
        else:
            raise TypeError(f"Expected str, bytes, Image, or Callable, got {type(source)}")
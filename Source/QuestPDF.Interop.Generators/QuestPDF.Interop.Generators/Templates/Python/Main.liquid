# AUTO-GENERATED on {{ generationDateTime }}


import os
from cffi import FFI
from typing import Callable, Optional, Tuple, Any, Self, Protocol, overload, Union

from dataclasses import dataclass

import warnings
import functools

try:
    from warnings import deprecated
except ImportError:
    def deprecated(reason: str):
        def decorator(func):
            @functools.wraps(func)
            def wrapper(*args, **kwargs):
                warnings.warn(
                    reason,
                    DeprecationWarning,
                    stacklevel=2
                )
                return func(*args, **kwargs)

            return wrapper

        return decorator
    

questpdf_ffi = FFI()

QUESTPDF_CDEF = r"""
    typedef unsigned char      uint8_t;
    typedef signed char        int8_t;
    typedef unsigned short     uint16_t;
    typedef short              int16_t;
    typedef unsigned int       uint32_t;
    typedef int                int32_t;
    typedef unsigned long long uint64_t;
    typedef long long          int64_t;
    
"""

class QuestPDF:
    def __init__(self):
        self.lib = None

questpdf = QuestPDF()


def decode_text_as_utf_8(value) -> str:
    return questpdf_ffi.string(value).decode("utf-8")


def decode_byte_array(value) -> str:
    return questpdf_ffi.string(value)


class Size:
    None

class ImageSize:
    None


QUESTPDF_CDEF += r"""
    typedef struct Buffer {
        uint8_t* data;                // or: unsigned char* data;
        size_t   length;
    } Buffer;
"""

{% for fragment in fragments %}
{{ fragment }}
{% endfor %}





QUESTPDF_CDEF += r"""
    typedef void (*documentContainerDescriptorCallback)(void* document_container);
    typedef void (*pageDescriptorCallback)(void* page);

    int  questpdf_sum(int a, int b);

    void*  questpdf_document_create(documentContainerDescriptorCallback cb);
    Buffer questpdf_document_generate_pdf(void* document);
    void   questpdf_document_destroy(void* document);

    void   questpdf_document_container_add_page(void* document_container, pageDescriptorCallback cb);


    void   questpdf_page_set_margin(void* page, int margin);
    void*   questpdf_page_set_content(void* page);
    void*   questpdf_container_background(void* page, uint32_t color);

    void   questpdf_free_bytes(void* ptr);
"""




class DocumentContainer:
    def __init__(self, document_container_pointer: "questpdf_ffi.CData"):
        self.document_container_pointer = document_container_pointer
        # Keep Python refs to callbacks alive for as long as this container lives
        self._page_callbacks = []  # type: list["ffi.CData"]

    def page(self, configurator: Callable[[PageDescriptor], Any]) -> None:
        @questpdf_ffi.callback("void(void*)")
        def _internal_page_handler(page_pointer):
            page_object = PageDescriptor(page_pointer)
            configurator(page_object)

        # retain the callback to prevent it from being GC'ed
        self._page_callbacks.append(_internal_page_handler)
        questpdf.lib.questpdf_document_container_add_page(self.document_container_pointer, _internal_page_handler)



class Document:
    def __init__(self):
        self._document_ptr: Optional["questpdf_ffi.CData"] = None
        self._document_container_cb: Optional["questpdf_ffi.CData"] = None  # keep callback alive

    @classmethod
    def create(cls, configurator: Callable[[DocumentContainer], Any]) -> "Document":
        inst = cls()

        @questpdf_ffi.callback("void(void*)")
        def _internal_container_handler(document_container_pointer):
            document_container = DocumentContainer(document_container_pointer)
            configurator(document_container)

        inst._document_container_cb = _internal_container_handler
        inst._document_ptr = questpdf.lib.questpdf_document_create(inst._document_container_cb)
        return inst

    def generate_pdf(self) -> bytes:
        if self._document_ptr is None:
            raise RuntimeError("Document not created. Call create() first.")

        buf = questpdf.lib.questpdf_document_generate_pdf(self._document_ptr)  # returns Buffer by value
        try:
            # safer: copy to Python bytes, then free the native memory
            return questpdf_ffi.buffer(buf.data, buf.length)[:]
            # or: ffi.unpack(buf.data, buf.length)
        finally:
            questpdf.lib.questpdf_free_bytes(buf.data)

    def save_to_file(self, filename: str) -> "Document":
        pdf_bytes = self.generate_pdf()
        with open(filename, "wb") as f:
            f.write(pdf_bytes)
        return self

    def destroy(self) -> None:
        if self._document_ptr is not None:
            questpdf.lib.questpdf_document_destroy(self._document_ptr)
            self._document_ptr = None
            self._document_container_cb = None  # allow GC

    def __enter__(self):
        return self

    def __del__(self):
        # Make destruction idempotent and safe at interpreter shutdown
        try:
            self.destroy()
        except Exception:
            pass
        return False





questpdf_ffi.cdef(QUESTPDF_CDEF)

lib_path = os.path.abspath("./QuestPDF.Interop.dylib")
questpdf.lib = questpdf_ffi.dlopen(lib_path)


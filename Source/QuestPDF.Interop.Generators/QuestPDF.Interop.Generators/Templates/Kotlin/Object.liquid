{% macro renderMethodDefinition(method) %}
{% if method.deprecationMessage %}@Deprecated("{{ method.deprecationMessage }}"){% endif %}
{% if method.isStaticMethod %}@JvmStatic{% endif %}
fun {{ method.originalName }}({{ method.kotlinParameters }}){% if method.kotlinReturnType != 'Unit' %}: {{ method.kotlinReturnType }}{% endif %} {
{% for callback in method.callbacks %}
    // Create callback for {{ callback.parameterName }}
    val {{ callback.parameterName }}Callback = object : {{ callback.callbackInterfaceName }} {
    override fun callback(ptr: Pointer) {
    val obj = {{ callback.argumentTypeName }}(ptr)
    {{ callback.parameterName }}(obj)
    }
    }
    callbacks.add({{ callback.parameterName }}Callback)

{% endfor %}
{% if method.kotlinReturnType == 'Unit' %}
    lib().{{ method.nativeMethodName }}({{ method.nativeCallArgs }})
{% elsif method.returnsPointer %}
    val result = lib().{{ method.nativeMethodName }}({{ method.nativeCallArgs }})
    return {{ method.returnClassName }}(result)
{% else %}
    return lib().{{ method.nativeMethodName }}({{ method.nativeCallArgs }})
{% endif %}
}
{% endmacro %}

// ============================================================================
// {{ className }} - Native Function Interface
// ============================================================================

/**
 * JNA interface for {{ className }} native methods.
 */
private interface {{ className }}Native : Library {
{% for method in methods %}
    fun {{ method.nativeMethodName }}({% unless method.isStaticMethod %}target: Pointer{% for param in method.parameters %}, {{ param.name }}: {{ param.jnaType }}{% endfor %}{% else %}{% for param in method.parameters %}{% if forloop.first == false %}, {% endif %}{{ param.name }}: {{ param.jnaType }}{% endfor %}{% endunless %}): {{ method.jnaReturnType }}
{% endfor %}
}

// ============================================================================
// {{ className }} Callback Interfaces
// ============================================================================

{% for callback in callbackInterfaces %}
/**
 * Callback interface for {{ callback.argumentTypeName }} configuration.
 */
interface {{ callback.interfaceName }} : Callback {
    fun callback(ptr: Pointer)
}

{% endfor %}
// ============================================================================
// {{ className }} Class
// ============================================================================

/**
 * {{ className }} wrapper for the native QuestPDF {{ className }}.
 */
class {{ className }} internal constructor(val pointer: Pointer) {
    private val callbacks = mutableListOf<Callback>()

    companion object {
        @Volatile
        private var nativeLib: {{ className }}Native? = null
        private val initLock = Any()

        private fun ensureInitialized() {
            if (nativeLib != null) return

            synchronized(initLock) {
                if (nativeLib != null) return
                nativeLib = Native.load(getLibraryPath(), {{ className }}Native::class.java, jnaOptions)
            }
        }

        private fun getLibraryPath(): String {
            val os = System.getProperty("os.name").lowercase()
            val libName = when {
                "win" in os -> "QuestPDF.Interop.dll"
                "mac" in os -> "QuestPDF.Interop.dylib"
                else -> "libQuestPDF.Interop.so"
            }

            val searchPaths = listOf(
                libName,
                "./$libName",
                "../$libName",
                "${System.getProperty("user.dir")}/$libName"
            )

            for (path in searchPaths) {
                val file = java.io.File(path)
                if (file.exists()) {
                    return file.absolutePath
                }
            }

            return libName
        }

        private fun lib(): {{ className }}Native {
            ensureInitialized()
            return nativeLib!!
        }

    {% for method in methods %}
        {% if method.isStaticMethod %} {{ renderMethodDefinition(method) }} {% endif %}
    {% endfor %}
    }

    init {
        ensureInitialized()
    }
    
{% for method in methods %}
{% unless method.isStaticMethod %} {{ renderMethodDefinition(method) }} {% endunless %}
{% endfor %}
}

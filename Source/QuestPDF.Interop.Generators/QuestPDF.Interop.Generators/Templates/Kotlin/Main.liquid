// AUTO-GENERATED on {{ generationDateTime }}
// QuestPDF Kotlin Bindings using JNA (Java Native Access)

@file:Suppress("unused", "MemberVisibilityCanBePrivate", "FunctionName")

package com.questpdf.interop

import com.sun.jna.*
import java.io.File
import java.io.FileOutputStream
import java.util.Collections

var jnaOptions = Collections.singletonMap(Library.OPTION_STRING_ENCODING, "UTF-16LE");

private class QuestLibrary {
    companion object {
        private val initLock = Any()

        private fun getLibraryPath(): String {
            val os = System.getProperty("os.name").lowercase()
            val libName = when {
                "win" in os -> "QuestPDF.Interop.dll"
                "mac" in os -> "QuestPDF.Interop.dylib"
                else -> "libQuestPDF.Interop.so"
            }

            val searchPaths = listOf(
                libName,
                "./$libName",
                "../$libName",
                "${System.getProperty("user.dir")}/$libName"
            )

            for (path in searchPaths) {
                val file = java.io.File(path)
                if (file.exists()) {
                    return file.absolutePath
                }
            }

            return libName
        }

        fun <T : Library> getLibrary(interfaceClass : Class<T>): T {
            synchronized(initLock) {
                return Native.load(getLibraryPath(), interfaceClass, jnaOptions)
            }
        }
    }
}
        
        

// ============================================================================
// Native Buffer Structure
// ============================================================================

/**
 * Native buffer structure for receiving byte arrays from native code.
 */
@Structure.FieldOrder("data", "length")
open class NativeBuffer : Structure {
    @JvmField var data: Pointer? = null
    @JvmField var length: NativeLong = NativeLong(0)

    constructor() : super()
    constructor(p: Pointer) : super(p) {
        read()
    }

    class ByValue : NativeBuffer(), Structure.ByValue
}

// ============================================================================
// Callback Interfaces
// ============================================================================

/**
 * Callback interface for pointer-based callbacks.
 * JNA requires a single method interface extending Callback.
 */
interface PointerCallback : Callback {
    fun callback(ptr: Pointer)
}

// ============================================================================
// Native Library Interface
// ============================================================================

/**
 * JNA interface for the QuestPDF native library.
 */
interface QuestPDFNative : Library {
    // Test function
    fun questpdf_sum(a: Int, b: Int): Int

    // Document lifecycle
    fun questpdf_document_create(cb: PointerCallback): Pointer
    fun questpdf_document_generate_pdf(document: Pointer): NativeBuffer.ByValue
    fun questpdf_document_destroy(document: Pointer)

    // Document container
    fun questpdf_document_container_add_page(container: Pointer, cb: PointerCallback)

    // Page descriptor
    fun questpdf_page_set_margin(page: Pointer, margin: Int)
    fun questpdf_page_set_content(page: Pointer): Pointer

    // Container
    fun questpdf_container_background(container: Pointer, color: Int): Pointer

    // Memory management
    fun questpdf_free_bytes(ptr: Pointer)
}

// ============================================================================
// Library Loading
// ============================================================================

/**
 * QuestPDF library manager for loading and accessing the native library.
 */
object QuestPDF {
    @Volatile
    private var lib: QuestPDFNative? = null
    private val lock = Any()

    /**
     * Gets the native library instance.
     * @throws IllegalStateException if the library is not initialized.
     */
    fun getLib(): QuestPDFNative {
        return lib ?: throw IllegalStateException("QuestPDF library not initialized. Call initialize() first.")
    }

    /**
     * Initializes the QuestPDF library with automatic platform detection.
     */
    fun initialize() {
        initialize(null)
    }

    /**
     * Initializes the QuestPDF library with a specific library path.
     * @param libraryPath Path to the native library, or null for auto-detection.
     */
    fun initialize(libraryPath: String?) {
        if (lib != null) return

        synchronized(lock) {
            if (lib != null) return

            val libPath = libraryPath ?: getDefaultLibraryPath()
            lib = Native.load(libPath, QuestPDFNative::class.java, jnaOptions)
        }
    }

    /**
     * Tests if the native library is working correctly.
     * @return true if the test passes.
     */
    fun test(): Boolean {
        return try {
            val result = getLib().questpdf_sum(2, 3)
            result == 5
        } catch (e: Exception) {
            false
        }
    }

    private fun getDefaultLibraryPath(): String {
        val os = System.getProperty("os.name").lowercase()
        val libName = when {
            "win" in os -> "QuestPDF.Interop.dll"
            "mac" in os -> "QuestPDF.Interop.dylib"
            else -> "libQuestPDF.Interop.so"
        }

        // Try multiple locations
        val searchPaths = listOf(
            libName,
            "./$libName",
            "../$libName",
            "${System.getProperty("user.dir")}/$libName"
        )

        for (path in searchPaths) {
            val file = File(path)
            if (file.exists()) {
                return file.absolutePath
            }
        }

        // Fall back to library name only, let JNA resolve it
        return libName
    }
}

// ============================================================================
// Core Classes
// ============================================================================

/**
 * Represents a page in a QuestPDF document.
 */
class Page internal constructor(val pointer: Pointer) {

    /**
     * Sets the margin for this page.
     */
    fun margin(margin: Int) {
        QuestPDF.getLib().questpdf_page_set_margin(pointer, margin)
    }

    /**
     * Gets the content container for this page.
     */
    fun content(): Container {
        val result = QuestPDF.getLib().questpdf_page_set_content(pointer)
        return Container(result)
    }
}

/**
 * Represents a document container for adding pages.
 */
class DocumentContainer internal constructor(val pointer: Pointer) {
    // Keep strong references to callbacks to prevent GC
    private val callbacks = mutableListOf<Callback>()

    /**
     * Adds a page to the document.
     */
    fun page(configurator: (Page) -> Unit) {
        val callback = object : PointerCallback {
            override fun callback(ptr: Pointer) {
                val page = Page(ptr)
                configurator(page)
            }
        }

        // Keep callback reference to prevent GC
        callbacks.add(callback)
        QuestPDF.getLib().questpdf_document_container_add_page(pointer, callback)
    }
}

/**
 * Represents a QuestPDF document.
 */
class Document private constructor() {
    private var ptr: Pointer? = null
    // Keep strong references to callbacks to prevent GC
    private val callbacks = mutableListOf<Callback>()

    companion object {
        /**
         * Creates a new document with the given configuration.
         */
        fun create(configurator: (DocumentContainer) -> Unit): Document {
            val doc = Document()

            val containerCallback = object : PointerCallback {
                override fun callback(ptr: Pointer) {
                    val container = DocumentContainer(ptr)
                    configurator(container)
                }
            }

            // Keep callback reference to prevent GC
            doc.callbacks.add(containerCallback)
            doc.ptr = QuestPDF.getLib().questpdf_document_create(containerCallback)
            return doc
        }
    }

    /**
     * Generates the PDF as a byte array.
     */
    fun generatePdf(): ByteArray {
        val currentPtr = ptr ?: throw IllegalStateException("Document not created. Use Document.create() first.")

        val buffer = QuestPDF.getLib().questpdf_document_generate_pdf(currentPtr)
        return try {
            val length = buffer.length.toInt()
            buffer.data!!.getByteArray(0, length)
        } finally {
            QuestPDF.getLib().questpdf_free_bytes(buffer.data!!)
        }
    }

    /**
     * Saves the PDF to a file.
     */
    fun saveToFile(filename: String): Document {
        val pdfBytes = generatePdf()
        FileOutputStream(filename).use { fos ->
            fos.write(pdfBytes)
        }
        return this
    }

    /**
     * Destroys the document and frees native resources.
     */
    fun destroy() {
        ptr?.let {
            QuestPDF.getLib().questpdf_document_destroy(it)
            ptr = null
            callbacks.clear()
        }
    }
}

// ============================================================================
// Generated Code
// ============================================================================

{% for fragment in fragments %}
{{ fragment }}
{% endfor %}

// ============================================================================
// {{ className }} - Native Function Declarations
// ============================================================================

{{ customDefinitions }}

{% for typedef in callbackTypedefs %}
// {{ typedef }}
{% endfor %}

const {{ className }}NativeFunctions: Record<string, ((...args: any[]) => any) | null> = {};

function init{{ className }}Functions(lib: koffi.IKoffiLib): void {
{% for method in methods %}
  {{ className }}NativeFunctions['{{ method.nativeMethodName }}'] = lib.func('{{ method.cSignature }}');
{% endfor %}

{{ customInit }}
}

// Register initialization with the global initializers
classInitializers.push((lib: koffi.IKoffiLib) => init{{ className }}Functions(lib));

// ============================================================================
// {{ className }} Class
// ============================================================================

export class {{ className }} {
  private readonly _ptr: NativePointer;
  private readonly _callbacks: koffi.IKoffiRegisteredCallback[] = [];

  constructor(ptr: NativePointer) {
    this._ptr = ptr;
  }

  get pointer(): NativePointer {
    return this._ptr;
  }

{% for method in methods %}
  {% if method.deprecationMessage %}/** @deprecated {{ method.deprecationMessage }} */{% endif %}
    {% if method.isStaticMethod %}static {% endif %}{% if method.isOverload %}private {% endif %}{{ method.tsMethodName }}({{ method.tsParameters }}): {{ method.tsReturnType }} {
{% for callback in method.callbacks %}
    // Create callback type and register handler
    const {{ callback.parameterName }}CallbackType_{{ method.uniqueId }} = koffi.proto('void {{ callback.parameterName }}Cb_{{ method.uniqueId }}(void* ptr)');
    const {{ callback.parameterName }}CallbackPtr_{{ method.uniqueId }} = koffi.pointer({{ callback.parameterName }}CallbackType_{{ method.uniqueId }});
    const {{ callback.parameterName }}Cb = koffi.register((ptr: NativePointer) => {
      const obj = new {{ callback.argumentTypeName }}(ptr);
      {{ callback.parameterName }}(obj);
    }, {{ callback.parameterName }}CallbackPtr_{{ method.uniqueId }});
    this._callbacks.push({{ callback.parameterName }}Cb);
{% endfor %}

    const result = {{ className }}NativeFunctions['{{ method.nativeMethodName }}']!({{ method.nativeCallArgs }});
{% if method.tsReturnType != 'void' %}
    return new {{ method.returnClassName }}(result);
{% endif %}
  }

{% endfor %}

{{ customClass }}
}

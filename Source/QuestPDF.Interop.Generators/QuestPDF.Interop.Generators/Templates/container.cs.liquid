using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using QuestPDF.Fluent;
using QuestPDF.Infrastructure;

namespace QuestPDF.Interop2;

internal unsafe partial class {{ class_name }}
{
    static IntPtr BoxHandle(object obj)
    {
        var gch = GCHandle.Alloc(obj, GCHandleType.Normal);
        return GCHandle.ToIntPtr(gch);
    }

    static T UnboxHandle<T>(nint handle) where T : class
    {
        var gch = GCHandle.FromIntPtr(handle);
        return (T)gch.Target!;
    }

    static void FreeHandle(nint handle)
    {
        if (handle == 0) return;
        var gch = GCHandle.FromIntPtr(handle);
        if (gch.IsAllocated) gch.Free();
    }
    
    {{ for method in methods }}
    [UnmanagedCallersOnly(EntryPoint = "{{ method.native_name }}", CallConvs = new[] { typeof(CallConvCdecl) })]
    public static IntPtr {{ method.managed_name }}({{ method.method_parameters | array.join ", " }})
    {
        var containerObject = UnboxHandle<IContainer>({{ method.target_object_parameter_name }});
        FreeHandle({{ method.target_object_parameter_name }});
        var result = containerObject.{{ method.api_name }}({{ method.target_method_parameters | array.join ", " }});
        return BoxHandle(result);
    }
    {{ end }}
}
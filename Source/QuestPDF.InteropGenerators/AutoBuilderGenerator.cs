using System.Diagnostics;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace QuestPDF.InteropGenerators;

[Generator]
public sealed class AutoBuilderGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        if (!Debugger.IsAttached)
            Debugger.Launch();
        
        while (!Debugger.IsAttached)
            Thread.Sleep(100);
        
        Debugger.Break();
        
        
        // 1) Find candidate classes with [AutoBuilder]
        var classesWithAttribute = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) =>
                    node is ClassDeclarationSyntax cds && cds.AttributeLists.Count > 0,
                transform: static (ctx, _) =>
                {
                    var cds = (ClassDeclarationSyntax)ctx.Node;
                    foreach (var list in cds.AttributeLists)
                    foreach (var attr in list.Attributes)
                    {
                        var model = ctx.SemanticModel;
                        var symbolInfo = model.GetSymbolInfo(attr).Symbol;
                        var attrType = symbolInfo switch
                        {
                            IMethodSymbol ms when ms.ContainingType is not null => ms.ContainingType,
                            _ => model.GetTypeInfo(attr).Type
                        };

                        if (attrType?.ToDisplayString()?.Contains("AutoBuilder") ?? false)
                            return cds;
                    }
                    return null;
                })
            .Where(static cds => cds is not null)!;

        // 2) Combine with compilation (to resolve symbols)
        var compilationAndClasses = context.CompilationProvider
            .Combine(classesWithAttribute.Collect());

        // 3) Generate
        context.RegisterSourceOutput(compilationAndClasses, static (spc, pair) =>
        {
            var (compilation, classDecls) = (pair.Left, pair.Right);
            foreach (var cds in classDecls!)
            {
                var model = compilation.GetSemanticModel(cds.SyntaxTree);
                if (model.GetDeclaredSymbol(cds) is not INamedTypeSymbol classSymbol)
                    continue;

                var ns = classSymbol.ContainingNamespace.IsGlobalNamespace
                            ? null
                            : classSymbol.ContainingNamespace.ToDisplayString();

                var className = classSymbol.Name;
                var builderName = className + "Builder";

                var sb = new StringBuilder();
                sb.AppendLine("// <auto-generated/>");
                if (ns is not null) sb.AppendLine($"namespace {ns};");
                sb.AppendLine($"public partial class {builderName}");
                sb.AppendLine("{");
                sb.AppendLine($"    private {className} _instance = new();");

                foreach (var m in classSymbol.GetMembers())
                {
                    if (m is IPropertySymbol p && !p.IsReadOnly && p.SetMethod is not null)
                    {
                        sb.AppendLine($"    public {builderName} With{p.Name}({p.Type.ToDisplayString()} value) {{ _instance.{p.Name} = value; return this; }}");
                    }
                }

                sb.AppendLine($"    public {className} Build() => _instance;");
                sb.AppendLine("}");

                spc.AddSource($"{builderName}.g.cs", sb.ToString());
            }
        });
    }
}
